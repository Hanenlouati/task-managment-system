import { Injectable, Injector, Optional, SkipSelf, Inject } from '@angular/core';
import { forkJoin, from, of, throwError, Subject, isObservable } from 'rxjs';
import { catchError, defaultIfEmpty, filter, map, mergeMap, shareReplay, takeUntil } from 'rxjs/operators';
import { INITIAL_STATE_TOKEN, memoize } from '@ngxs/store/internals';
import { META_KEY, NgxsConfig } from '../symbols';
import { buildGraph, findFullParentPath, isObject, nameToState, propGetter, topologicalSort, getStoreMetadata } from './internals';
import { getActionTypeFromInstance, getValue, setValue } from '../utils/utils';
import { ofActionDispatched } from '../operators/of-action';
import { InternalActions } from '../actions-stream';
import { InternalDispatchedActionResults } from '../internal/dispatcher';
import { StateContextFactory } from '../internal/state-context-factory';
import { StoreValidators } from '../utils/store-validators';
import { ensureStateClassIsInjectable } from '../ivy/ivy-enabled-in-dev-mode';
import { NgxsUnhandledActionsLogger } from '../dev-features/ngxs-unhandled-actions-logger';
import * as i0 from "@angular/core";
import * as i1 from "../symbols";
import * as i2 from "../actions-stream";
import * as i3 from "../internal/dispatcher";
import * as i4 from "../internal/state-context-factory";
/**
 * State factory class
 * @ignore
 */
export class StateFactory {
    constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {
        this._injector = _injector;
        this._config = _config;
        this._parentFactory = _parentFactory;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._stateContextFactory = _stateContextFactory;
        this._initialState = _initialState;
        this._actionsSubscription = null;
        this._states = [];
        this._statesByName = {};
        this._statePaths = {};
        this.getRuntimeSelectorContext = memoize(() => {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const stateFactory = this;
            function resolveGetter(key) {
                const path = stateFactory.statePaths[key];
                return path ? propGetter(path.split('.'), stateFactory._config) : null;
            }
            const context = this._parentFactory
                ? this._parentFactory.getRuntimeSelectorContext()
                : {
                    getStateGetter(key) {
                        let getter = resolveGetter(key);
                        if (getter) {
                            return getter;
                        }
                        return (...args) => {
                            // Late loaded getter
                            if (!getter) {
                                getter = resolveGetter(key);
                            }
                            return getter ? getter(...args) : undefined;
                        };
                    },
                    getSelectorOptions(localOptions) {
                        const globalSelectorOptions = stateFactory._config.selectorOptions;
                        return Object.assign(Object.assign({}, globalSelectorOptions), (localOptions || {}));
                    }
                };
            return context;
        });
    }
    get states() {
        return this._parentFactory ? this._parentFactory.states : this._states;
    }
    get statesByName() {
        return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;
    }
    get statePaths() {
        return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;
    }
    static cloneDefaults(defaults) {
        let value = {};
        if (Array.isArray(defaults)) {
            value = defaults.slice();
        }
        else if (isObject(defaults)) {
            value = Object.assign({}, defaults);
        }
        else if (defaults === undefined) {
            value = {};
        }
        else {
            value = defaults;
        }
        return value;
    }
    ngOnDestroy() {
        // This is being non-null asserted since `_actionsSubscrition` is
        // initialized within the constructor.
        this._actionsSubscription.unsubscribe();
    }
    /**
     * Add a new state to the global defs.
     */
    add(stateClasses) {
        // Caretaker note: we have still left the `typeof` condition in order to avoid
        // creating a breaking change for projects that still use the View Engine.
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            StoreValidators.checkThatStateClassesHaveBeenDecorated(stateClasses);
        }
        const { newStates } = this.addToStatesMap(stateClasses);
        if (!newStates.length)
            return [];
        const stateGraph = buildGraph(newStates);
        const sortedStates = topologicalSort(stateGraph);
        const paths = findFullParentPath(stateGraph);
        const nameGraph = nameToState(newStates);
        const bootstrappedStores = [];
        for (const name of sortedStates) {
            const stateClass = nameGraph[name];
            const path = paths[name];
            const meta = stateClass[META_KEY];
            this.addRuntimeInfoToMeta(meta, path);
            // Note: previously we called `ensureStateClassIsInjectable` within the
            // `State` decorator. This check is moved here because the `ɵprov` property
            // will not exist on the class in JIT mode (because it's set asynchronously
            // during JIT compilation through `Object.defineProperty`).
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
                ensureStateClassIsInjectable(stateClass);
            }
            const stateMap = {
                name,
                path,
                isInitialised: false,
                actions: meta.actions,
                instance: this._injector.get(stateClass),
                defaults: StateFactory.cloneDefaults(meta.defaults)
            };
            // ensure our store hasn't already been added
            // but don't throw since it could be lazy
            // loaded from different paths
            if (!this.hasBeenMountedAndBootstrapped(name, path)) {
                bootstrappedStores.push(stateMap);
            }
            this.states.push(stateMap);
        }
        return bootstrappedStores;
    }
    /**
     * Add a set of states to the store and return the defaults
     */
    addAndReturnDefaults(stateClasses) {
        const classes = stateClasses || [];
        const mappedStores = this.add(classes);
        const defaults = mappedStores.reduce((result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults), {});
        return { defaults, states: mappedStores };
    }
    /**
     * Bind the actions to the handlers
     */
    connectActionHandlers() {
        if (this._actionsSubscription !== null)
            return;
        const dispatched$ = new Subject();
        this._actionsSubscription = this._actions
            .pipe(filter((ctx) => ctx.status === "DISPATCHED" /* Dispatched */), mergeMap(ctx => {
            dispatched$.next(ctx);
            const action = ctx.action;
            return this.invokeActions(dispatched$, action).pipe(map(() => ({ action, status: "SUCCESSFUL" /* Successful */ })), defaultIfEmpty({ action, status: "CANCELED" /* Canceled */ }), catchError(error => of({ action, status: "ERRORED" /* Errored */, error })));
        }))
            .subscribe(ctx => this._actionResults.next(ctx));
    }
    /**
     * Invoke actions on the states.
     */
    invokeActions(dispatched$, action) {
        const type = getActionTypeFromInstance(action);
        const results = [];
        // Determines whether the dispatched action has been handled, this is assigned
        // to `true` within the below `for` loop if any `actionMetas` has been found.
        let actionHasBeenHandled = false;
        for (const metadata of this.states) {
            const actionMetas = metadata.actions[type];
            if (actionMetas) {
                for (const actionMeta of actionMetas) {
                    const stateContext = this._stateContextFactory.createStateContext(metadata);
                    try {
                        let result = metadata.instance[actionMeta.fn](stateContext, action);
                        if (result instanceof Promise) {
                            result = from(result);
                        }
                        if (isObservable(result)) {
                            // If this observable has been completed w/o emitting
                            // any value then we wouldn't want to complete the whole chain
                            // of actions. Since if any observable completes then
                            // action will be canceled.
                            // For instance if any action handler would've had such statement:
                            // `handler(ctx) { return EMPTY; }`
                            // then the action will be canceled.
                            // See https://github.com/ngxs/store/issues/1568
                            result = result.pipe(mergeMap((value) => {
                                if (value instanceof Promise) {
                                    return from(value);
                                }
                                if (isObservable(value)) {
                                    return value;
                                }
                                return of(value);
                            }), defaultIfEmpty({}));
                            if (actionMeta.options.cancelUncompleted) {
                                // todo: ofActionDispatched should be used with action class
                                result = result.pipe(takeUntil(dispatched$.pipe(ofActionDispatched(action))));
                            }
                        }
                        else {
                            result = of({}).pipe(shareReplay());
                        }
                        results.push(result);
                    }
                    catch (e) {
                        results.push(throwError(e));
                    }
                    actionHasBeenHandled = true;
                }
            }
        }
        // The `NgxsUnhandledActionsLogger` is a tree-shakable class which functions
        // only during development.
        if ((typeof ngDevMode === 'undefined' || ngDevMode) && !actionHasBeenHandled) {
            const unhandledActionsLogger = this._injector.get(NgxsUnhandledActionsLogger, null);
            // The `NgxsUnhandledActionsLogger` will not be resolved by the injector if the
            // `NgxsDevelopmentModule` is not provided. It's enough to check whether the `injector.get`
            // didn't return `null` so we may ensure the module has been imported.
            if (unhandledActionsLogger) {
                unhandledActionsLogger.warn(action);
            }
        }
        if (!results.length) {
            results.push(of({}));
        }
        return forkJoin(results);
    }
    addToStatesMap(stateClasses) {
        const newStates = [];
        const statesMap = this.statesByName;
        for (const stateClass of stateClasses) {
            const stateName = getStoreMetadata(stateClass).name;
            // Caretaker note: we have still left the `typeof` condition in order to avoid
            // creating a breaking change for projects that still use the View Engine.
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
                StoreValidators.checkThatStateNameIsUnique(stateName, stateClass, statesMap);
            }
            const unmountedState = !statesMap[stateName];
            if (unmountedState) {
                newStates.push(stateClass);
                statesMap[stateName] = stateClass;
            }
        }
        return { newStates };
    }
    addRuntimeInfoToMeta(meta, path) {
        this.statePaths[meta.name] = path;
        // TODO: v4 - we plan to get rid of the path property because it is non-deterministic
        // we can do this when we get rid of the incorrectly exposed getStoreMetadata
        // We will need to come up with an alternative in v4 because this is used by many plugins
        meta.path = path;
    }
    /**
     * @description
     * the method checks if the state has already been added to the tree
     * and completed the life cycle
     * @param name
     * @param path
     */
    hasBeenMountedAndBootstrapped(name, path) {
        const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;
        return this.statesByName[name] && valueIsBootstrappedInInitialState;
    }
}
/** @nocollapse */ StateFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: StateFactory, deps: [{ token: i0.Injector }, { token: i1.NgxsConfig }, { token: StateFactory, optional: true, skipSelf: true }, { token: i2.InternalActions }, { token: i3.InternalDispatchedActionResults }, { token: i4.StateContextFactory }, { token: INITIAL_STATE_TOKEN, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ StateFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: StateFactory });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: StateFactory, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1.NgxsConfig }, { type: StateFactory, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }, { type: i2.InternalActions }, { type: i3.InternalDispatchedActionResults }, { type: i4.StateContextFactory }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [INITIAL_STATE_TOKEN]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL3N0b3JlL3NyYy9pbnRlcm5hbC9zdGF0ZS1mYWN0b3J5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFhLE1BQU0sZUFBZSxDQUFDO0FBQzVGLE9BQU8sRUFDTCxRQUFRLEVBQ1IsSUFBSSxFQUVKLEVBQUUsRUFDRixVQUFVLEVBRVYsT0FBTyxFQUNQLFlBQVksRUFDYixNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFDTCxVQUFVLEVBQ1YsY0FBYyxFQUNkLE1BQU0sRUFDTixHQUFHLEVBQ0gsUUFBUSxFQUNSLFdBQVcsRUFDWCxTQUFTLEVBQ1YsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBQUUsbUJBQW1CLEVBQWlCLE9BQU8sRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRXBGLE9BQU8sRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ2xELE9BQU8sRUFDTCxVQUFVLEVBQ1Ysa0JBQWtCLEVBQ2xCLFFBQVEsRUFHUixXQUFXLEVBQ1gsVUFBVSxFQUtWLGVBQWUsRUFHZixnQkFBZ0IsRUFDakIsTUFBTSxhQUFhLENBQUM7QUFDckIsT0FBTyxFQUFFLHlCQUF5QixFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMvRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUM1RCxPQUFPLEVBQStCLGVBQWUsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ2pGLE9BQU8sRUFBRSwrQkFBK0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxl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RUFBRSxTQUFTLEVBQUUsQ0FBQztJQUN2QixDQUFDO0lBRU8sb0JBQW9CLENBQUMsSUFBbUIsRUFBRSxJQUFZO1FBQzVELElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUssQ0FBQyxHQUFHLElBQUksQ0FBQztRQUNuQyxxRkFBcUY7UUFDckYsNkVBQTZFO1FBQzdFLHlGQUF5RjtRQUN6RixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztJQUNuQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ssNkJBQTZCLENBQUMsSUFBWSxFQUFFLElBQVk7UUFDOUQsTUFBTSxpQ0FBaUMsR0FDckMsUUFBUSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLEtBQUssU0FBUyxDQUFDO1FBQ25ELE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxpQ0FBaUMsQ0FBQztJQUN0RSxDQUFDOzs2SEEzVFUsWUFBWSxvRUFRRyxZQUFZLDhKQUs1QixtQkFBbUI7aUlBYmxCLFlBQVk7NEZBQVosWUFBWTtrQkFEeEIsVUFBVTswR0FTaUIsWUFBWTswQkFGbkMsUUFBUTs7MEJBQ1IsUUFBUTs7MEJBS1IsUUFBUTs7MEJBQ1IsTUFBTTsyQkFBQyxtQkFBbUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3RvciwgT3B0aW9uYWwsIFNraXBTZWxmLCBJbmplY3QsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgZm9ya0pvaW4sXG4gIGZyb20sXG4gIE9ic2VydmFibGUsXG4gIG9mLFxuICB0aHJvd0Vycm9yLFxuICBTdWJzY3JpcHRpb24sXG4gIFN1YmplY3QsXG4gIGlzT2JzZXJ2YWJsZVxufSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIGNhdGNoRXJyb3IsXG4gIGRlZmF1bHRJZkVtcHR5LFxuICBmaWx0ZXIsXG4gIG1hcCxcbiAgbWVyZ2VNYXAsXG4gIHNoYXJlUmVwbGF5LFxuICB0YWtlVW50aWxcbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgSU5JVElBTF9TVEFURV9UT0tFTiwgUGxhaW5PYmplY3RPZiwgbWVtb2l6ZSB9IGZyb20gJ0BuZ3hzL3N0b3JlL2ludGVybmFscyc7XG5cbmltcG9ydCB7IE1FVEFfS0VZLCBOZ3hzQ29uZmlnIH0gZnJvbSAnLi4vc3ltYm9scyc7XG5pbXBvcnQge1xuICBidWlsZEdyYXBoLFxuICBmaW5kRnVsbFBhcmVudFBhdGgsXG4gIGlzT2JqZWN0LFxuICBNYXBwZWRTdG9yZSxcbiAgTWV0YURhdGFNb2RlbCxcbiAgbmFtZVRvU3RhdGUsXG4gIHByb3BHZXR0ZXIsXG4gIFN0YXRlQ2xhc3NJbnRlcm5hbCxcbiAgU3RhdGVLZXlHcmFwaCxcbiAgU3RhdGVzQW5kRGVmYXVsdHMsXG4gIFN0YXRlc0J5TmFtZSxcbiAgdG9wb2xvZ2ljYWxTb3J0LFxuICBSdW50aW1lU2VsZWN0b3JDb250ZXh0LFxuICBTaGFyZWRTZWxlY3Rvck9wdGlvbnMsXG4gIGdldFN0b3JlTWV0YWRhdGFcbn0gZnJvbSAnLi9pbnRlcm5hbHMnO1xuaW1wb3J0IHsgZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZSwgZ2V0VmFsdWUsIHNldFZhbHVlIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IHsgb2ZBY3Rpb25EaXNwYXRjaGVkIH0gZnJvbSAnLi4vb3BlcmF0b3JzL29mLWFjdGlvbic7XG5pbXBvcnQgeyBBY3Rpb25Db250ZXh0LCBBY3Rpb25TdGF0dXMsIEludGVybmFsQWN0aW9ucyB9IGZyb20gJy4uL2FjdGlvbnMtc3RyZWFtJztcbmltcG9ydCB7IEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMgfSBmcm9tICcuLi9pbnRlcm5hbC9kaXNwYXRjaGVyJztcbmltcG9ydCB7IFN0YXRlQ29udGV4dEZhY3RvcnkgfSBmcm9tICcuLi9pbnRlcm5hbC9zdGF0ZS1jb250ZXh0LWZhY3RvcnknO1xuaW1wb3J0IHsgU3RvcmVWYWxpZGF0b3JzIH0gZnJvbSAnLi4vdXRpbHMvc3RvcmUtdmFsaWRhdG9ycyc7XG5pbXBvcnQgeyBlbnN1cmVTdGF0ZUNsYXNzSXNJbmplY3RhYmxlIH0gZnJvbSAnLi4vaXZ5L2l2eS1lbmFibGVkLWluLWRldi1tb2RlJztcbmltcG9ydCB7IE5neHNVbmhhbmRsZWRBY3Rpb25zTG9nZ2VyIH0gZnJvbSAnLi4vZGV2LWZlYXR1cmVzL25neHMtdW5oYW5kbGVkLWFjdGlvbnMtbG9nZ2VyJztcblxuLyoqXG4gKiBTdGF0ZSBmYWN0b3J5IGNsYXNzXG4gKiBAaWdub3JlXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTdGF0ZUZhY3RvcnkgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIF9hY3Rpb25zU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9pbmplY3RvcjogSW5qZWN0b3IsXG4gICAgcHJpdmF0ZSBfY29uZmlnOiBOZ3hzQ29uZmlnLFxuICAgIEBPcHRpb25hbCgpXG4gICAgQFNraXBTZWxmKClcbiAgICBwcml2YXRlIF9wYXJlbnRGYWN0b3J5OiBTdGF0ZUZhY3RvcnksXG4gICAgcHJpdmF0ZSBfYWN0aW9uczogSW50ZXJuYWxBY3Rpb25zLFxuICAgIHByaXZhdGUgX2FjdGlvblJlc3VsdHM6IEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMsXG4gICAgcHJpdmF0ZSBfc3RhdGVDb250ZXh0RmFjdG9yeTogU3RhdGVDb250ZXh0RmFjdG9yeSxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoSU5JVElBTF9TVEFURV9UT0tFTilcbiAgICBwcml2YXRlIF9pbml0aWFsU3RhdGU6IGFueVxuICApIHt9XG5cbiAgcHJpdmF0ZSBfc3RhdGVzOiBNYXBwZWRTdG9yZVtdID0gW107XG5cbiAgZ2V0IHN0YXRlcygpOiBNYXBwZWRTdG9yZVtdIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50RmFjdG9yeSA/IHRoaXMuX3BhcmVudEZhY3Rvcnkuc3RhdGVzIDogdGhpcy5fc3RhdGVzO1xuICB9XG5cbiAgcHJpdmF0ZSBfc3RhdGVzQnlOYW1lOiBTdGF0ZXNCeU5hbWUgPSB7fTtcblxuICBnZXQgc3RhdGVzQnlOYW1lKCk6IFN0YXRlc0J5TmFtZSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEZhY3RvcnkgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LnN0YXRlc0J5TmFtZSA6IHRoaXMuX3N0YXRlc0J5TmFtZTtcbiAgfVxuXG4gIHByaXZhdGUgX3N0YXRlUGF0aHM6IFBsYWluT2JqZWN0T2Y8c3RyaW5nPiA9IHt9O1xuXG4gIHByaXZhdGUgZ2V0IHN0YXRlUGF0aHMoKTogUGxhaW5PYmplY3RPZjxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50RmFjdG9yeSA/IHRoaXMuX3BhcmVudEZhY3Rvcnkuc3RhdGVQYXRocyA6IHRoaXMuX3N0YXRlUGF0aHM7XG4gIH1cblxuICBnZXRSdW50aW1lU2VsZWN0b3JDb250ZXh0ID0gbWVtb2l6ZSgoKSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgY29uc3Qgc3RhdGVGYWN0b3J5ID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIHJlc29sdmVHZXR0ZXIoa2V5OiBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IHBhdGggPSBzdGF0ZUZhY3Rvcnkuc3RhdGVQYXRoc1trZXldO1xuICAgICAgcmV0dXJuIHBhdGggPyBwcm9wR2V0dGVyKHBhdGguc3BsaXQoJy4nKSwgc3RhdGVGYWN0b3J5Ll9jb25maWcpIDogbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZXh0OiBSdW50aW1lU2VsZWN0b3JDb250ZXh0ID0gdGhpcy5fcGFyZW50RmFjdG9yeVxuICAgICAgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LmdldFJ1bnRpbWVTZWxlY3RvckNvbnRleHQoKVxuICAgICAgOiB7XG4gICAgICAgICAgZ2V0U3RhdGVHZXR0ZXIoa2V5OiBzdHJpbmcpIHtcbiAgICAgICAgICAgIGxldCBnZXR0ZXIgPSByZXNvbHZlR2V0dGVyKGtleSk7XG4gICAgICAgICAgICBpZiAoZ2V0dGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXR0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgLy8gTGF0ZSBsb2FkZWQgZ2V0dGVyXG4gICAgICAgICAgICAgIGlmICghZ2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgZ2V0dGVyID0gcmVzb2x2ZUdldHRlcihrZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIoLi4uYXJncykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0U2VsZWN0b3JPcHRpb25zKGxvY2FsT3B0aW9ucz86IFNoYXJlZFNlbGVjdG9yT3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZ2xvYmFsU2VsZWN0b3JPcHRpb25zID0gc3RhdGVGYWN0b3J5Ll9jb25maWcuc2VsZWN0b3JPcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uZ2xvYmFsU2VsZWN0b3JPcHRpb25zLFxuICAgICAgICAgICAgICAuLi4obG9jYWxPcHRpb25zIHx8IHt9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH0pO1xuXG4gIHByaXZhdGUgc3RhdGljIGNsb25lRGVmYXVsdHMoZGVmYXVsdHM6IGFueSk6IGFueSB7XG4gICAgbGV0IHZhbHVlID0ge307XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZhdWx0cykpIHtcbiAgICAgIHZhbHVlID0gZGVmYXVsdHMuc2xpY2UoKTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGRlZmF1bHRzKSkge1xuICAgICAgdmFsdWUgPSB7IC4uLmRlZmF1bHRzIH07XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWx1ZSA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGRlZmF1bHRzO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIC8vIFRoaXMgaXMgYmVpbmcgbm9uLW51bGwgYXNzZXJ0ZWQgc2luY2UgYF9hY3Rpb25zU3Vic2NyaXRpb25gIGlzXG4gICAgLy8gaW5pdGlhbGl6ZWQgd2l0aGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICB0aGlzLl9hY3Rpb25zU3Vic2NyaXB0aW9uIS51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBzdGF0ZSB0byB0aGUgZ2xvYmFsIGRlZnMuXG4gICAqL1xuICBhZGQoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSk6IE1hcHBlZFN0b3JlW10ge1xuICAgIC8vIENhcmV0YWtlciBub3RlOiB3ZSBoYXZlIHN0aWxsIGxlZnQgdGhlIGB0eXBlb2ZgIGNvbmRpdGlvbiBpbiBvcmRlciB0byBhdm9pZFxuICAgIC8vIGNyZWF0aW5nIGEgYnJlYWtpbmcgY2hhbmdlIGZvciBwcm9qZWN0cyB0aGF0IHN0aWxsIHVzZSB0aGUgVmlldyBFbmdpbmUuXG4gICAgaWYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkge1xuICAgICAgU3RvcmVWYWxpZGF0b3JzLmNoZWNrVGhhdFN0YXRlQ2xhc3Nlc0hhdmVCZWVuRGVjb3JhdGVkKHN0YXRlQ2xhc3Nlcyk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBuZXdTdGF0ZXMgfSA9IHRoaXMuYWRkVG9TdGF0ZXNNYXAoc3RhdGVDbGFzc2VzKTtcbiAgICBpZiAoIW5ld1N0YXRlcy5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgIGNvbnN0IHN0YXRlR3JhcGg6IFN0YXRlS2V5R3JhcGggPSBidWlsZEdyYXBoKG5ld1N0YXRlcyk7XG4gICAgY29uc3Qgc29ydGVkU3RhdGVzOiBzdHJpbmdbXSA9IHRvcG9sb2dpY2FsU29ydChzdGF0ZUdyYXBoKTtcbiAgICBjb25zdCBwYXRoczogUGxhaW5PYmplY3RPZjxzdHJpbmc+ID0gZmluZEZ1bGxQYXJlbnRQYXRoKHN0YXRlR3JhcGgpO1xuICAgIGNvbnN0IG5hbWVHcmFwaDogUGxhaW5PYmplY3RPZjxTdGF0ZUNsYXNzSW50ZXJuYWw+ID0gbmFtZVRvU3RhdGUobmV3U3RhdGVzKTtcbiAgICBjb25zdCBib290c3RyYXBwZWRTdG9yZXM6IE1hcHBlZFN0b3JlW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBzb3J0ZWRTdGF0ZXMpIHtcbiAgICAgIGNvbnN0IHN0YXRlQ2xhc3M6IFN0YXRlQ2xhc3NJbnRlcm5hbCA9IG5hbWVHcmFwaFtuYW1lXTtcbiAgICAgIGNvbnN0IHBhdGg6IHN0cmluZyA9IHBhdGhzW25hbWVdO1xuICAgICAgY29uc3QgbWV0YTogTWV0YURhdGFNb2RlbCA9IHN0YXRlQ2xhc3NbTUVUQV9LRVldITtcblxuICAgICAgdGhpcy5hZGRSdW50aW1lSW5mb1RvTWV0YShtZXRhLCBwYXRoKTtcblxuICAgICAgLy8gTm90ZTogcHJldmlvdXNseSB3ZSBjYWxsZWQgYGVuc3VyZVN0YXRlQ2xhc3NJc0luamVjdGFibGVgIHdpdGhpbiB0aGVcbiAgICAgIC8vIGBTdGF0ZWAgZGVjb3JhdG9yLiBUaGlzIGNoZWNrIGlzIG1vdmVkIGhlcmUgYmVjYXVzZSB0aGUgYMm1cHJvdmAgcHJvcGVydHlcbiAgICAgIC8vIHdpbGwgbm90IGV4aXN0IG9uIHRoZSBjbGFzcyBpbiBKSVQgbW9kZSAoYmVjYXVzZSBpdCdzIHNldCBhc3luY2hyb25vdXNseVxuICAgICAgLy8gZHVyaW5nIEpJVCBjb21waWxhdGlvbiB0aHJvdWdoIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgKS5cbiAgICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgZW5zdXJlU3RhdGVDbGFzc0lzSW5qZWN0YWJsZShzdGF0ZUNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhdGVNYXA6IE1hcHBlZFN0b3JlID0ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBwYXRoLFxuICAgICAgICBpc0luaXRpYWxpc2VkOiBmYWxzZSxcbiAgICAgICAgYWN0aW9uczogbWV0YS5hY3Rpb25zLFxuICAgICAgICBpbnN0YW5jZTogdGhpcy5faW5qZWN0b3IuZ2V0KHN0YXRlQ2xhc3MpLFxuICAgICAgICBkZWZhdWx0czogU3RhdGVGYWN0b3J5LmNsb25lRGVmYXVsdHMobWV0YS5kZWZhdWx0cylcbiAgICAgIH07XG5cbiAgICAgIC8vIGVuc3VyZSBvdXIgc3RvcmUgaGFzbid0IGFscmVhZHkgYmVlbiBhZGRlZFxuICAgICAgLy8gYnV0IGRvbid0IHRocm93IHNpbmNlIGl0IGNvdWxkIGJlIGxhenlcbiAgICAgIC8vIGxvYWRlZCBmcm9tIGRpZmZlcmVudCBwYXRoc1xuICAgICAgaWYgKCF0aGlzLmhhc0JlZW5Nb3VudGVkQW5kQm9vdHN0cmFwcGVkKG5hbWUsIHBhdGgpKSB7XG4gICAgICAgIGJvb3RzdHJhcHBlZFN0b3Jlcy5wdXNoKHN0YXRlTWFwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGF0ZXMucHVzaChzdGF0ZU1hcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvb3RzdHJhcHBlZFN0b3JlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBzZXQgb2Ygc3RhdGVzIHRvIHRoZSBzdG9yZSBhbmQgcmV0dXJuIHRoZSBkZWZhdWx0c1xuICAgKi9cbiAgYWRkQW5kUmV0dXJuRGVmYXVsdHMoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSk6IFN0YXRlc0FuZERlZmF1bHRzIHtcbiAgICBjb25zdCBjbGFzc2VzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSA9IHN0YXRlQ2xhc3NlcyB8fCBbXTtcblxuICAgIGNvbnN0IG1hcHBlZFN0b3JlczogTWFwcGVkU3RvcmVbXSA9IHRoaXMuYWRkKGNsYXNzZXMpO1xuICAgIGNvbnN0IGRlZmF1bHRzID0gbWFwcGVkU3RvcmVzLnJlZHVjZShcbiAgICAgIChyZXN1bHQ6IGFueSwgbWFwcGVkU3RvcmU6IE1hcHBlZFN0b3JlKSA9PlxuICAgICAgICBzZXRWYWx1ZShyZXN1bHQsIG1hcHBlZFN0b3JlLnBhdGgsIG1hcHBlZFN0b3JlLmRlZmF1bHRzKSxcbiAgICAgIHt9XG4gICAgKTtcbiAgICByZXR1cm4geyBkZWZhdWx0cywgc3RhdGVzOiBtYXBwZWRTdG9yZXMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kIHRoZSBhY3Rpb25zIHRvIHRoZSBoYW5kbGVyc1xuICAgKi9cbiAgY29ubmVjdEFjdGlvbkhhbmRsZXJzKCkge1xuICAgIGlmICh0aGlzLl9hY3Rpb25zU3Vic2NyaXB0aW9uICE9PSBudWxsKSByZXR1cm47XG4gICAgY29uc3QgZGlzcGF0Y2hlZCQgPSBuZXcgU3ViamVjdDxBY3Rpb25Db250ZXh0PigpO1xuICAgIHRoaXMuX2FjdGlvbnNTdWJzY3JpcHRpb24gPSB0aGlzLl9hY3Rpb25zXG4gICAgICAucGlwZShcbiAgICAgICAgZmlsdGVyKChjdHg6IEFjdGlvbkNvbnRleHQpID0+IGN0eC5zdGF0dXMgPT09IEFjdGlvblN0YXR1cy5EaXNwYXRjaGVkKSxcbiAgICAgICAgbWVyZ2VNYXAoY3R4ID0+IHtcbiAgICAgICAgICBkaXNwYXRjaGVkJC5uZXh0KGN0eCk7XG4gICAgICAgICAgY29uc3QgYWN0aW9uID0gY3R4LmFjdGlvbjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbnZva2VBY3Rpb25zKGRpc3BhdGNoZWQkLCBhY3Rpb24hKS5waXBlKFxuICAgICAgICAgICAgbWFwKCgpID0+IDxBY3Rpb25Db250ZXh0PnsgYWN0aW9uLCBzdGF0dXM6IEFjdGlvblN0YXR1cy5TdWNjZXNzZnVsIH0pLFxuICAgICAgICAgICAgZGVmYXVsdElmRW1wdHkoPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLkNhbmNlbGVkIH0pLFxuICAgICAgICAgICAgY2F0Y2hFcnJvcihlcnJvciA9PlxuICAgICAgICAgICAgICBvZig8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuRXJyb3JlZCwgZXJyb3IgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9KVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZShjdHggPT4gdGhpcy5fYWN0aW9uUmVzdWx0cy5uZXh0KGN0eCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZSBhY3Rpb25zIG9uIHRoZSBzdGF0ZXMuXG4gICAqL1xuICBpbnZva2VBY3Rpb25zKGRpc3BhdGNoZWQkOiBPYnNlcnZhYmxlPEFjdGlvbkNvbnRleHQ+LCBhY3Rpb246IGFueSkge1xuICAgIGNvbnN0IHR5cGUgPSBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlKGFjdGlvbikhO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIC8vIERldGVybWluZXMgd2hldGhlciB0aGUgZGlzcGF0Y2hlZCBhY3Rpb24gaGFzIGJlZW4gaGFuZGxlZCwgdGhpcyBpcyBhc3NpZ25lZFxuICAgIC8vIHRvIGB0cnVlYCB3aXRoaW4gdGhlIGJlbG93IGBmb3JgIGxvb3AgaWYgYW55IGBhY3Rpb25NZXRhc2AgaGFzIGJlZW4gZm91bmQuXG4gICAgbGV0IGFjdGlvbkhhc0JlZW5IYW5kbGVkID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IG1ldGFkYXRhIG9mIHRoaXMuc3RhdGVzKSB7XG4gICAgICBjb25zdCBhY3Rpb25NZXRhcyA9IG1ldGFkYXRhLmFjdGlvbnNbdHlwZV07XG5cbiAgICAgIGlmIChhY3Rpb25NZXRhcykge1xuICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbk1ldGEgb2YgYWN0aW9uTWV0YXMpIHtcbiAgICAgICAgICBjb25zdCBzdGF0ZUNvbnRleHQgPSB0aGlzLl9zdGF0ZUNvbnRleHRGYWN0b3J5LmNyZWF0ZVN0YXRlQ29udGV4dChtZXRhZGF0YSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtZXRhZGF0YS5pbnN0YW5jZVthY3Rpb25NZXRhLmZuXShzdGF0ZUNvbnRleHQsIGFjdGlvbik7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZyb20ocmVzdWx0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoaXMgb2JzZXJ2YWJsZSBoYXMgYmVlbiBjb21wbGV0ZWQgdy9vIGVtaXR0aW5nXG4gICAgICAgICAgICAgIC8vIGFueSB2YWx1ZSB0aGVuIHdlIHdvdWxkbid0IHdhbnQgdG8gY29tcGxldGUgdGhlIHdob2xlIGNoYWluXG4gICAgICAgICAgICAgIC8vIG9mIGFjdGlvbnMuIFNpbmNlIGlmIGFueSBvYnNlcnZhYmxlIGNvbXBsZXRlcyB0aGVuXG4gICAgICAgICAgICAgIC8vIGFjdGlvbiB3aWxsIGJlIGNhbmNlbGVkLlxuICAgICAgICAgICAgICAvLyBGb3IgaW5zdGFuY2UgaWYgYW55IGFjdGlvbiBoYW5kbGVyIHdvdWxkJ3ZlIGhhZCBzdWNoIHN0YXRlbWVudDpcbiAgICAgICAgICAgICAgLy8gYGhhbmRsZXIoY3R4KSB7IHJldHVybiBFTVBUWTsgfWBcbiAgICAgICAgICAgICAgLy8gdGhlbiB0aGUgYWN0aW9uIHdpbGwgYmUgY2FuY2VsZWQuXG4gICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbmd4cy9zdG9yZS9pc3N1ZXMvMTU2OFxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShcbiAgICAgICAgICAgICAgICBtZXJnZU1hcCgodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJvbSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoaXNPYnNlcnZhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gb2YodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRJZkVtcHR5KHt9KVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIGlmIChhY3Rpb25NZXRhLm9wdGlvbnMuY2FuY2VsVW5jb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvOiBvZkFjdGlvbkRpc3BhdGNoZWQgc2hvdWxkIGJlIHVzZWQgd2l0aCBhY3Rpb24gY2xhc3NcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShcbiAgICAgICAgICAgICAgICAgIHRha2VVbnRpbChkaXNwYXRjaGVkJC5waXBlKG9mQWN0aW9uRGlzcGF0Y2hlZChhY3Rpb24gYXMgYW55KSkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gb2Yoe30pLnBpcGUoc2hhcmVSZXBsYXkoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aHJvd0Vycm9yKGUpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhY3Rpb25IYXNCZWVuSGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGUgYE5neHNVbmhhbmRsZWRBY3Rpb25zTG9nZ2VyYCBpcyBhIHRyZWUtc2hha2FibGUgY2xhc3Mgd2hpY2ggZnVuY3Rpb25zXG4gICAgLy8gb25seSBkdXJpbmcgZGV2ZWxvcG1lbnQuXG4gICAgaWYgKCh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpICYmICFhY3Rpb25IYXNCZWVuSGFuZGxlZCkge1xuICAgICAgY29uc3QgdW5oYW5kbGVkQWN0aW9uc0xvZ2dlciA9IHRoaXMuX2luamVjdG9yLmdldChOZ3hzVW5oYW5kbGVkQWN0aW9uc0xvZ2dlciwgbnVsbCk7XG4gICAgICAvLyBUaGUgYE5neHNVbmhhbmRsZWRBY3Rpb25zTG9nZ2VyYCB3aWxsIG5vdCBiZSByZXNvbHZlZCBieSB0aGUgaW5qZWN0b3IgaWYgdGhlXG4gICAgICAvLyBgTmd4c0RldmVsb3BtZW50TW9kdWxlYCBpcyBub3QgcHJvdmlkZWQuIEl0J3MgZW5vdWdoIHRvIGNoZWNrIHdoZXRoZXIgdGhlIGBpbmplY3Rvci5nZXRgXG4gICAgICAvLyBkaWRuJ3QgcmV0dXJuIGBudWxsYCBzbyB3ZSBtYXkgZW5zdXJlIHRoZSBtb2R1bGUgaGFzIGJlZW4gaW1wb3J0ZWQuXG4gICAgICBpZiAodW5oYW5kbGVkQWN0aW9uc0xvZ2dlcikge1xuICAgICAgICB1bmhhbmRsZWRBY3Rpb25zTG9nZ2VyLndhcm4oYWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICByZXN1bHRzLnB1c2gob2Yoe30pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ya0pvaW4ocmVzdWx0cyk7XG4gIH1cblxuICBwcml2YXRlIGFkZFRvU3RhdGVzTWFwKFxuICAgIHN0YXRlQ2xhc3NlczogU3RhdGVDbGFzc0ludGVybmFsW11cbiAgKTogeyBuZXdTdGF0ZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdIH0ge1xuICAgIGNvbnN0IG5ld1N0YXRlczogU3RhdGVDbGFzc0ludGVybmFsW10gPSBbXTtcbiAgICBjb25zdCBzdGF0ZXNNYXA6IFN0YXRlc0J5TmFtZSA9IHRoaXMuc3RhdGVzQnlOYW1lO1xuXG4gICAgZm9yIChjb25zdCBzdGF0ZUNsYXNzIG9mIHN0YXRlQ2xhc3Nlcykge1xuICAgICAgY29uc3Qgc3RhdGVOYW1lID0gZ2V0U3RvcmVNZXRhZGF0YShzdGF0ZUNsYXNzKS5uYW1lITtcbiAgICAgIC8vIENhcmV0YWtlciBub3RlOiB3ZSBoYXZlIHN0aWxsIGxlZnQgdGhlIGB0eXBlb2ZgIGNvbmRpdGlvbiBpbiBvcmRlciB0byBhdm9pZFxuICAgICAgLy8gY3JlYXRpbmcgYSBicmVha2luZyBjaGFuZ2UgZm9yIHByb2plY3RzIHRoYXQgc3RpbGwgdXNlIHRoZSBWaWV3IEVuZ2luZS5cbiAgICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgU3RvcmVWYWxpZGF0b3JzLmNoZWNrVGhhdFN0YXRlTmFtZUlzVW5pcXVlKHN0YXRlTmFtZSwgc3RhdGVDbGFzcywgc3RhdGVzTWFwKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVubW91bnRlZFN0YXRlID0gIXN0YXRlc01hcFtzdGF0ZU5hbWVdO1xuICAgICAgaWYgKHVubW91bnRlZFN0YXRlKSB7XG4gICAgICAgIG5ld1N0YXRlcy5wdXNoKHN0YXRlQ2xhc3MpO1xuICAgICAgICBzdGF0ZXNNYXBbc3RhdGVOYW1lXSA9IHN0YXRlQ2xhc3M7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbmV3U3RhdGVzIH07XG4gIH1cblxuICBwcml2YXRlIGFkZFJ1bnRpbWVJbmZvVG9NZXRhKG1ldGE6IE1ldGFEYXRhTW9kZWwsIHBhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuc3RhdGVQYXRoc1ttZXRhLm5hbWUhXSA9IHBhdGg7XG4gICAgLy8gVE9ETzogdjQgLSB3ZSBwbGFuIHRvIGdldCByaWQgb2YgdGhlIHBhdGggcHJvcGVydHkgYmVjYXVzZSBpdCBpcyBub24tZGV0ZXJtaW5pc3RpY1xuICAgIC8vIHdlIGNhbiBkbyB0aGlzIHdoZW4gd2UgZ2V0IHJpZCBvZiB0aGUgaW5jb3JyZWN0bHkgZXhwb3NlZCBnZXRTdG9yZU1ldGFkYXRhXG4gICAgLy8gV2Ugd2lsbCBuZWVkIHRvIGNvbWUgdXAgd2l0aCBhbiBhbHRlcm5hdGl2ZSBpbiB2NCBiZWNhdXNlIHRoaXMgaXMgdXNlZCBieSBtYW55IHBsdWdpbnNcbiAgICBtZXRhLnBhdGggPSBwYXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiB0aGUgbWV0aG9kIGNoZWNrcyBpZiB0aGUgc3RhdGUgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0byB0aGUgdHJlZVxuICAgKiBhbmQgY29tcGxldGVkIHRoZSBsaWZlIGN5Y2xlXG4gICAqIEBwYXJhbSBuYW1lXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqL1xuICBwcml2YXRlIGhhc0JlZW5Nb3VudGVkQW5kQm9vdHN0cmFwcGVkKG5hbWU6IHN0cmluZywgcGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdmFsdWVJc0Jvb3RzdHJhcHBlZEluSW5pdGlhbFN0YXRlOiBib29sZWFuID1cbiAgICAgIGdldFZhbHVlKHRoaXMuX2luaXRpYWxTdGF0ZSwgcGF0aCkgIT09IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZXNCeU5hbWVbbmFtZV0gJiYgdmFsdWVJc0Jvb3RzdHJhcHBlZEluSW5pdGlhbFN0YXRlO1xuICB9XG59XG4iXX0=